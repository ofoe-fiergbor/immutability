##IMMUTABLE DATA TYPES

Sometimes we want to create an object of a specific type whose contents cannot be changed once
it has been created. Such objects are immutable objects with an immutable class.

All information contained in each instance of a mutable object is created and is fixed for the lifetime of the object.

`String` is an example of an immutable type. A `String` object always represents the same string.
Since `String` is immutable, once created, a `String` object always has the same value.

The `String` class comes with a `.append()` object that tempts you into believing that merely 
appending a string to your current string object mutates it. That's not the case.

Under the hood, `.append()` actually copies your existing string object, 
appends a string to it, then return a new `String` object. Hence, pointing your variable to another memory reference. 


By contrast, `StringBuilder` objects are mutable. This class has methods that change the value of the object, 
rather than just returning new values.

Other java platform library primitive classes include boxed primitive classes, BigInteger and BigDecimal

##To create an immutable data type / class:
<ol>
    <li>The class itself can't be extended.</li>
    <li>All data fields must be private and final.</li>
    <li>There can't be any setter method.</li>
    <li>There can't be any getter method that returns a mutable data field.</li>
</ol>

###Example1:
```
final class ImmutableClass {
    private final int x;
    
    public ImmutableClass(int x) {
        this.x = x;
    }
    public int getX() {
        return this.x;
    }
}
```
###Example2:
```
final class ImmutableClass {
    private final int x;
    private final List<Integer> grades;

    public ImmutableClass(int x, List<Integer> grades) {
        this.x = x;
        this.grades = grades;
    }
    public int getX() {
        return this.x;
    }

    public List<Integer> getGrades() {
        return new ArrayList<>(this.grades);
    }
}
```
###Pros:
<ul>
    <li>Safe from bugs and more secure.</li>
    <li>Easy to understand.</li>
</ul>

###Cons:
<ul>
    <li>The require a separate object for each distinct value.</li>
</ul>

-- Reference: [Effective Java - Item 15: Minimize mutability](https://books.google.com/books?id=ka2VUBqHiWkC&pg=PA73&lpg=PA73&dq=effective+java+item+15&source=bl&ots=yZHgLmo5QY&sig=LmSUtLEuA9_8X0BAs22iEg2IkZw&hl=en&sa=X&ved=0ahUKEwjH7rjY4oDKAhXEcA8KHd7jCeMQ6AEIKzAC#v=onepage&q=effective%20java%20item%2015&f=false)